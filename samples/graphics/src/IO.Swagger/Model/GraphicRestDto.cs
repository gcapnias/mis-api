/* 
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// graphic for defining Track or Radar Processing regions
    /// </summary>
    [DataContract]
        public partial class GraphicRestDto :  IEquatable<GraphicRestDto>, IValidatableObject
    {
        /// <summary>
        /// How tracks within this region are acquired or processed. The values which can be reported are one of TRACK_LAND_MASK, IMAGE_LAND_MASK, ACQUISITION_WINDOW, GUARD_ALARM, THRESHOLD_BIAS_MAP, SPECIAL1, SPECIAL2, ACQUISITION_AIS, ACQUISITION_IFF, ACQUISITION_RESERVED_1, ACQUISITION_RESERVED_2, DEAD_RECKONING, MANEUVERING_SENSITIVITY
        /// </summary>
        /// <value>How tracks within this region are acquired or processed. The values which can be reported are one of TRACK_LAND_MASK, IMAGE_LAND_MASK, ACQUISITION_WINDOW, GUARD_ALARM, THRESHOLD_BIAS_MAP, SPECIAL1, SPECIAL2, ACQUISITION_AIS, ACQUISITION_IFF, ACQUISITION_RESERVED_1, ACQUISITION_RESERVED_2, DEAD_RECKONING, MANEUVERING_SENSITIVITY</value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum GraphicProcessingTypeEnum
        {
            /// <summary>
            /// Enum TRACKLANDMASK for value: TRACK_LAND_MASK
            /// </summary>
            [EnumMember(Value = "TRACK_LAND_MASK")]
            TRACKLANDMASK = 1,
            /// <summary>
            /// Enum ACQUISITIONWINDOW for value: ACQUISITION_WINDOW
            /// </summary>
            [EnumMember(Value = "ACQUISITION_WINDOW")]
            ACQUISITIONWINDOW = 2,
            /// <summary>
            /// Enum ACQUISITIONAIS for value: ACQUISITION_AIS
            /// </summary>
            [EnumMember(Value = "ACQUISITION_AIS")]
            ACQUISITIONAIS = 3,
            /// <summary>
            /// Enum ACQUISITIONIFF for value: ACQUISITION_IFF
            /// </summary>
            [EnumMember(Value = "ACQUISITION_IFF")]
            ACQUISITIONIFF = 4        }
        /// <summary>
        /// How tracks within this region are acquired or processed. The values which can be reported are one of TRACK_LAND_MASK, IMAGE_LAND_MASK, ACQUISITION_WINDOW, GUARD_ALARM, THRESHOLD_BIAS_MAP, SPECIAL1, SPECIAL2, ACQUISITION_AIS, ACQUISITION_IFF, ACQUISITION_RESERVED_1, ACQUISITION_RESERVED_2, DEAD_RECKONING, MANEUVERING_SENSITIVITY
        /// </summary>
        /// <value>How tracks within this region are acquired or processed. The values which can be reported are one of TRACK_LAND_MASK, IMAGE_LAND_MASK, ACQUISITION_WINDOW, GUARD_ALARM, THRESHOLD_BIAS_MAP, SPECIAL1, SPECIAL2, ACQUISITION_AIS, ACQUISITION_IFF, ACQUISITION_RESERVED_1, ACQUISITION_RESERVED_2, DEAD_RECKONING, MANEUVERING_SENSITIVITY</value>
        [DataMember(Name="graphicProcessingType", EmitDefaultValue=false)]
        public GraphicProcessingTypeEnum? GraphicProcessingType { get; set; }
        /// <summary>
        /// the pending state of the graphic in response to a request (POST,PUT,DELETE) accepted at the MIS. Shown as one of a pending state, a failed state, or not shown. (The typical case is that the request is accepted by the RP server within a couple of seconds and the showing the pending state is very short-lived.) &lt;/br&gt;If and when the request is accepted by the RP server (as determined by a positive acknowledgement at MIS) then the pending state is cleared and no longer shown. &lt;/br&gt;If the request is not accepted by the RP server (as determined by lack of a positive acknowledgement at MIS) then the request eventually goes (after 1 to 30 seconds or so) from a pending state to a failed state and this failed state is shown for about 10 seconds before being cleared. &lt;/br&gt;Therefore it is recommended that the user of this API poll for this response via the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint to know the status.&lt;/br&gt;Please note that a &#x27;Create Graphic&#x27; (POST) is shown only from the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint and not the &#x27;GET /graphics/{unitNumber}&#x27; endpoint. 
        /// </summary>
        /// <value>the pending state of the graphic in response to a request (POST,PUT,DELETE) accepted at the MIS. Shown as one of a pending state, a failed state, or not shown. (The typical case is that the request is accepted by the RP server within a couple of seconds and the showing the pending state is very short-lived.) &lt;/br&gt;If and when the request is accepted by the RP server (as determined by a positive acknowledgement at MIS) then the pending state is cleared and no longer shown. &lt;/br&gt;If the request is not accepted by the RP server (as determined by lack of a positive acknowledgement at MIS) then the request eventually goes (after 1 to 30 seconds or so) from a pending state to a failed state and this failed state is shown for about 10 seconds before being cleared. &lt;/br&gt;Therefore it is recommended that the user of this API poll for this response via the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint to know the status.&lt;/br&gt;Please note that a &#x27;Create Graphic&#x27; (POST) is shown only from the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint and not the &#x27;GET /graphics/{unitNumber}&#x27; endpoint. </value>
        [JsonConverter(typeof(StringEnumConverter))]
                public enum PendingStateEnum
        {
            /// <summary>
            /// Enum PendingCreate for value: pending-create
            /// </summary>
            [EnumMember(Value = "pending-create")]
            PendingCreate = 1,
            /// <summary>
            /// Enum FailedCreate for value: failed-create
            /// </summary>
            [EnumMember(Value = "failed-create")]
            FailedCreate = 2,
            /// <summary>
            /// Enum PendingUpdate for value: pending-update
            /// </summary>
            [EnumMember(Value = "pending-update")]
            PendingUpdate = 3,
            /// <summary>
            /// Enum FailedUpdate for value: failed-update
            /// </summary>
            [EnumMember(Value = "failed-update")]
            FailedUpdate = 4,
            /// <summary>
            /// Enum PendingDelete for value: pending-delete
            /// </summary>
            [EnumMember(Value = "pending-delete")]
            PendingDelete = 5,
            /// <summary>
            /// Enum FailedDelete for value: failed-delete
            /// </summary>
            [EnumMember(Value = "failed-delete")]
            FailedDelete = 6        }
        /// <summary>
        /// the pending state of the graphic in response to a request (POST,PUT,DELETE) accepted at the MIS. Shown as one of a pending state, a failed state, or not shown. (The typical case is that the request is accepted by the RP server within a couple of seconds and the showing the pending state is very short-lived.) &lt;/br&gt;If and when the request is accepted by the RP server (as determined by a positive acknowledgement at MIS) then the pending state is cleared and no longer shown. &lt;/br&gt;If the request is not accepted by the RP server (as determined by lack of a positive acknowledgement at MIS) then the request eventually goes (after 1 to 30 seconds or so) from a pending state to a failed state and this failed state is shown for about 10 seconds before being cleared. &lt;/br&gt;Therefore it is recommended that the user of this API poll for this response via the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint to know the status.&lt;/br&gt;Please note that a &#x27;Create Graphic&#x27; (POST) is shown only from the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint and not the &#x27;GET /graphics/{unitNumber}&#x27; endpoint. 
        /// </summary>
        /// <value>the pending state of the graphic in response to a request (POST,PUT,DELETE) accepted at the MIS. Shown as one of a pending state, a failed state, or not shown. (The typical case is that the request is accepted by the RP server within a couple of seconds and the showing the pending state is very short-lived.) &lt;/br&gt;If and when the request is accepted by the RP server (as determined by a positive acknowledgement at MIS) then the pending state is cleared and no longer shown. &lt;/br&gt;If the request is not accepted by the RP server (as determined by lack of a positive acknowledgement at MIS) then the request eventually goes (after 1 to 30 seconds or so) from a pending state to a failed state and this failed state is shown for about 10 seconds before being cleared. &lt;/br&gt;Therefore it is recommended that the user of this API poll for this response via the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint to know the status.&lt;/br&gt;Please note that a &#x27;Create Graphic&#x27; (POST) is shown only from the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint and not the &#x27;GET /graphics/{unitNumber}&#x27; endpoint. </value>
        [DataMember(Name="pendingState", EmitDefaultValue=false)]
        public PendingStateEnum? PendingState { get; set; }
        /// <summary>
        /// Initializes a new instance of the <see cref="GraphicRestDto" /> class.
        /// </summary>
        /// <param name="circle">circle.</param>
        /// <param name="graphicId">the graphic ID.</param>
        /// <param name="graphicProcessingType">How tracks within this region are acquired or processed. The values which can be reported are one of TRACK_LAND_MASK, IMAGE_LAND_MASK, ACQUISITION_WINDOW, GUARD_ALARM, THRESHOLD_BIAS_MAP, SPECIAL1, SPECIAL2, ACQUISITION_AIS, ACQUISITION_IFF, ACQUISITION_RESERVED_1, ACQUISITION_RESERVED_2, DEAD_RECKONING, MANEUVERING_SENSITIVITY.</param>
        /// <param name="links">*method&#x3D;GET*Provides link relations as URLs using the REST &#x27;hateoas&#x27; convention (for REST delivered data).&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The &#x27;self&#x27; link references this rest object, including any specified query criteria.</param>
        /// <param name="pendingState">the pending state of the graphic in response to a request (POST,PUT,DELETE) accepted at the MIS. Shown as one of a pending state, a failed state, or not shown. (The typical case is that the request is accepted by the RP server within a couple of seconds and the showing the pending state is very short-lived.) &lt;/br&gt;If and when the request is accepted by the RP server (as determined by a positive acknowledgement at MIS) then the pending state is cleared and no longer shown. &lt;/br&gt;If the request is not accepted by the RP server (as determined by lack of a positive acknowledgement at MIS) then the request eventually goes (after 1 to 30 seconds or so) from a pending state to a failed state and this failed state is shown for about 10 seconds before being cleared. &lt;/br&gt;Therefore it is recommended that the user of this API poll for this response via the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint to know the status.&lt;/br&gt;Please note that a &#x27;Create Graphic&#x27; (POST) is shown only from the &#x27;GET /graphics/{unitNumber}/{graphicId}&#x27; endpoint and not the &#x27;GET /graphics/{unitNumber}&#x27; endpoint. .</param>
        /// <param name="polygon">definition of a simple polygon (closed with no intersections). (circle and polygon are exclusive).</param>
        /// <param name="unitNumber">the unit number (id) of the rp or tracker.</param>
        /// <param name="updateTime">this communicates any changes to the graphic. It is set by the PCRP at creation or update of the graphic (or upon restart of the PCRP, all times are set to the restart time).</param>
        public GraphicRestDto(GraphicCircleRestDto circle = default(GraphicCircleRestDto), int? graphicId = default(int?), GraphicProcessingTypeEnum? graphicProcessingType = default(GraphicProcessingTypeEnum?), List<Link> links = default(List<Link>), PendingStateEnum? pendingState = default(PendingStateEnum?), List<GeoLatLonRestDto> polygon = default(List<GeoLatLonRestDto>), int? unitNumber = default(int?), string updateTime = default(string))
        {
            this.Circle = circle;
            this.GraphicId = graphicId;
            this.GraphicProcessingType = graphicProcessingType;
            this.Links = links;
            this.PendingState = pendingState;
            this.Polygon = polygon;
            this.UnitNumber = unitNumber;
            this.UpdateTime = updateTime;
        }
        
        /// <summary>
        /// Gets or Sets Circle
        /// </summary>
        [DataMember(Name="circle", EmitDefaultValue=false)]
        public GraphicCircleRestDto Circle { get; set; }

        /// <summary>
        /// the graphic ID
        /// </summary>
        /// <value>the graphic ID</value>
        [DataMember(Name="graphicId", EmitDefaultValue=false)]
        public int? GraphicId { get; set; }


        /// <summary>
        /// *method&#x3D;GET*Provides link relations as URLs using the REST &#x27;hateoas&#x27; convention (for REST delivered data).&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The &#x27;self&#x27; link references this rest object, including any specified query criteria
        /// </summary>
        /// <value>*method&#x3D;GET*Provides link relations as URLs using the REST &#x27;hateoas&#x27; convention (for REST delivered data).&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The &#x27;self&#x27; link references this rest object, including any specified query criteria</value>
        [DataMember(Name="links", EmitDefaultValue=false)]
        public List<Link> Links { get; set; }


        /// <summary>
        /// definition of a simple polygon (closed with no intersections). (circle and polygon are exclusive)
        /// </summary>
        /// <value>definition of a simple polygon (closed with no intersections). (circle and polygon are exclusive)</value>
        [DataMember(Name="polygon", EmitDefaultValue=false)]
        public List<GeoLatLonRestDto> Polygon { get; set; }

        /// <summary>
        /// the unit number (id) of the rp or tracker
        /// </summary>
        /// <value>the unit number (id) of the rp or tracker</value>
        [DataMember(Name="unitNumber", EmitDefaultValue=false)]
        public int? UnitNumber { get; set; }

        /// <summary>
        /// this communicates any changes to the graphic. It is set by the PCRP at creation or update of the graphic (or upon restart of the PCRP, all times are set to the restart time)
        /// </summary>
        /// <value>this communicates any changes to the graphic. It is set by the PCRP at creation or update of the graphic (or upon restart of the PCRP, all times are set to the restart time)</value>
        [DataMember(Name="updateTime", EmitDefaultValue=false)]
        public string UpdateTime { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class GraphicRestDto {\n");
            sb.Append("  Circle: ").Append(Circle).Append("\n");
            sb.Append("  GraphicId: ").Append(GraphicId).Append("\n");
            sb.Append("  GraphicProcessingType: ").Append(GraphicProcessingType).Append("\n");
            sb.Append("  Links: ").Append(Links).Append("\n");
            sb.Append("  PendingState: ").Append(PendingState).Append("\n");
            sb.Append("  Polygon: ").Append(Polygon).Append("\n");
            sb.Append("  UnitNumber: ").Append(UnitNumber).Append("\n");
            sb.Append("  UpdateTime: ").Append(UpdateTime).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as GraphicRestDto);
        }

        /// <summary>
        /// Returns true if GraphicRestDto instances are equal
        /// </summary>
        /// <param name="input">Instance of GraphicRestDto to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(GraphicRestDto input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Circle == input.Circle ||
                    (this.Circle != null &&
                    this.Circle.Equals(input.Circle))
                ) && 
                (
                    this.GraphicId == input.GraphicId ||
                    (this.GraphicId != null &&
                    this.GraphicId.Equals(input.GraphicId))
                ) && 
                (
                    this.GraphicProcessingType == input.GraphicProcessingType ||
                    (this.GraphicProcessingType != null &&
                    this.GraphicProcessingType.Equals(input.GraphicProcessingType))
                ) && 
                (
                    this.Links == input.Links ||
                    this.Links != null &&
                    input.Links != null &&
                    this.Links.SequenceEqual(input.Links)
                ) && 
                (
                    this.PendingState == input.PendingState ||
                    (this.PendingState != null &&
                    this.PendingState.Equals(input.PendingState))
                ) && 
                (
                    this.Polygon == input.Polygon ||
                    this.Polygon != null &&
                    input.Polygon != null &&
                    this.Polygon.SequenceEqual(input.Polygon)
                ) && 
                (
                    this.UnitNumber == input.UnitNumber ||
                    (this.UnitNumber != null &&
                    this.UnitNumber.Equals(input.UnitNumber))
                ) && 
                (
                    this.UpdateTime == input.UpdateTime ||
                    (this.UpdateTime != null &&
                    this.UpdateTime.Equals(input.UpdateTime))
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Circle != null)
                    hashCode = hashCode * 59 + this.Circle.GetHashCode();
                if (this.GraphicId != null)
                    hashCode = hashCode * 59 + this.GraphicId.GetHashCode();
                if (this.GraphicProcessingType != null)
                    hashCode = hashCode * 59 + this.GraphicProcessingType.GetHashCode();
                if (this.Links != null)
                    hashCode = hashCode * 59 + this.Links.GetHashCode();
                if (this.PendingState != null)
                    hashCode = hashCode * 59 + this.PendingState.GetHashCode();
                if (this.Polygon != null)
                    hashCode = hashCode * 59 + this.Polygon.GetHashCode();
                if (this.UnitNumber != null)
                    hashCode = hashCode * 59 + this.UnitNumber.GetHashCode();
                if (this.UpdateTime != null)
                    hashCode = hashCode * 59 + this.UpdateTime.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
